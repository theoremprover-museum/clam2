/*  This is a proof plan for theorem:
    prod_times: []==>u:pnat=>v:pnat list=>w:pnat=>prod(v)=w in pnat=>prod(u::v)=times(u,w)in pnat
    planner = dplan, clam_version(2.8.1), oyster_version($Id: prod_times,v 1.12 1999/05/10 13:21:29 img Exp $)

    Time taken to find plan: 650ms
    Environment:
    def(prod)
    def(times)
    def(plus)
    def(<=>)
    def(true)
    eqn(prod2)
    eqn(prod1)
    eqn(times2)
    eqn(times1)
    eqn(plus2)
    eqn(plus1)
    eqn(imp2)
    eqn(imp1)
    eqn(and4)
    eqn(and3)
    eqn(and2)
    eqn(and1)
    eqn(or4)
    eqn(or3)
    eqn(or2)
    eqn(or1)
    eqn(prod2)
    eqn(prod2)
    eqn(prod1)
    eqn(prod1)
    eqn(times2)
    eqn(times2)
    eqn(times1)
    eqn(plus2)
    eqn(plus2)
    eqn(plus1)
    eqn(imp2)
    eqn(imp2)
    eqn(imp1)
    eqn(and4)
    eqn(and4)
    eqn(and3)
    eqn(and3)
    eqn(and2)
    eqn(and1)
    eqn(or4)
    eqn(or3)
    eqn(or2)
    eqn(or2)
    eqn(or1)
    eqn(or1)
    eqn(disttwo)
    eqn(disttwo)
    wave(prod2)
    wave(prod2)
    wave(prod1)
    wave(prod1)
    wave(times2)
    wave(times2)
    wave(times1)
    wave(plus2)
    wave(plus2)
    wave(plus1)
    wave(imp2)
    wave(imp2)
    wave(imp1)
    wave(and4)
    wave(and4)
    wave(and3)
    wave(and3)
    wave(and2)
    wave(and1)
    wave(or4)
    wave(or3)
    wave(or2)
    wave(or2)
    wave(or1)
    wave(or1)
    wave(disttwo)
    wave(disttwo)
    red(prod2)
    red(prod1)
    red(times2)
    red(times1)
    red(plus2)
    red(plus1)
    red(imp2)
    red(imp1)
    red(and4)
    red(and3)
    red(and2)
    red(and1)
    red(or4)
    red(or3)
    red(or2)
    red(or1)
    trs(default)
    thm(prod_times)
    thm(disttwo)
    lemma(ipc_dp_imp_e4)
    lemma(ipc_dp_imp_e3)
    lemma(ipc_dp_imp_e2)
    lemma(cnc_s_bis)
    lemma(succ_nonzero_right)
    lemma(succ_nonzero_left)
    lemma(plesssucc2)
    lemma(plesssucc)
    lemma(list1)
    lemma(arith3)
    lemma(arith2)
    lemma(arith1)
    scheme(list_primitive)
    scheme(pnat_primitive)
    mthd(base_case/1)
    mthd(generalise/2)
    mthd(ind_strat/1)
    mthd(normalize/1)
    smthd(apply_lemma/1)
    smthd(backchain_lemma/1)
    smthd(base_case/1)
    smthd(cancellation/2)
    smthd(casesplit/1)
    smthd(elementary/1)
    smthd(equal/2)
    smthd(existential/2)
    smthd(fertilization_strong/1)
    smthd(fertilize/2)
    smthd(fertilize_left_or_right/1)
    smthd(induction/1)
    smthd(normal/1)
    smthd(normalize_term/1)
    smthd(pw_fertilize/1)
    smthd(pwf/1)
    smthd(pwf_then_fertilize/2)
    smthd(ripple/2)
    smthd(ripple_and_cancel/1)
    smthd(step_case/1)
    smthd(sym_eval/1)
    smthd(unblock/3)
    smthd(unblock_fertilize_lazy/1)
    smthd(unblock_lazy/1)
    smthd(unblock_then_fertilize/2)
    smthd(unblock_then_wave/2)
    smthd(wave/4)
    smthd(weak_fertilize/4)
 */

/* This is the pretty-printed form
base_case(...) then 
  generalise(...) then 
    normalize(...) then 
      base_case(...)

*/

proof_plan([]==>u:pnat=>v:pnat list=>w:pnat=>prod(v)=w in pnat=>prod(u::v)=times(u,w)in pnat,prod_times,650,base_case(normalize_term([reduction([1,1,2],[prod2,equ(pnat,left)])]))then[generalise(prod(v),v0:pnat)then[normalize([normal(univ_intro),normal(univ_intro),normal(univ_intro),normal(univ_intro),normal(imply_intro)])then[base_case(equal(v1,left)then[elementary(unfold_iff then identity)])]]],dplan).
