/*  This is a proof plan for theorem:
    maxhtminht: []==>t:int tree=>geq(maxht(t),minht(t))
    planner = dplan, clam_version(2.8.1), oyster_version($Id: maxhtminht,v 1.12 1999/05/10 13:21:15 img Exp $)

    Time taken to find plan: 1440ms
    Environment:
    def(pairord)
    def(snd)
    def(fst)
    def(pred)
    def(geq)
    def(minht)
    def(min)
    def(maxht)
    def(tree)
    def(leaf)
    def(node)
    def(max)
    def(<=>)
    def(true)
    eqn(snd1)
    eqn(fst1)
    eqn(pred2)
    eqn(pred1)
    eqn(geq3)
    eqn(geq2)
    eqn(geq1)
    eqn(minht2)
    eqn(minht1)
    eqn(min3)
    eqn(min2)
    eqn(min1)
    eqn(maxht2)
    eqn(maxht1)
    eqn(max3)
    eqn(max2)
    eqn(max1)
    eqn(imp2)
    eqn(imp1)
    eqn(and4)
    eqn(and3)
    eqn(and2)
    eqn(and1)
    eqn(or4)
    eqn(or3)
    eqn(or2)
    eqn(or1)
    eqn(minmaxgeq)
    eqn(minmaxgeq)
    eqn(snd1)
    eqn(fst1)
    eqn(pred2)
    eqn(pred1)
    eqn(pred1)
    eqn(geq3)
    eqn(geq3)
    eqn(geq2)
    eqn(geq1)
    eqn(minht2)
    eqn(minht2)
    eqn(minht1)
    eqn(min3)
    eqn(min3)
    eqn(min2)
    eqn(min1)
    eqn(maxht2)
    eqn(maxht2)
    eqn(maxht1)
    eqn(max3)
    eqn(max3)
    eqn(max2)
    eqn(max1)
    eqn(imp2)
    eqn(imp2)
    eqn(imp1)
    eqn(and4)
    eqn(and4)
    eqn(and3)
    eqn(and3)
    eqn(and2)
    eqn(and1)
    eqn(or4)
    eqn(or3)
    eqn(or2)
    eqn(or2)
    eqn(or1)
    eqn(or1)
    eqn(meminsert2)
    eqn(meminsert2)
    eqn(meminsert1)
    eqn(meminsert1)
    eqn(disttwo)
    eqn(disttwo)
    wave(minmaxgeq)
    wave(minmaxgeq)
    wave(snd1)
    wave(fst1)
    wave(pred2)
    wave(pred1)
    wave(pred1)
    wave(geq3)
    wave(geq3)
    wave(geq2)
    wave(geq1)
    wave(minht2)
    wave(minht2)
    wave(minht1)
    wave(min3)
    wave(min3)
    wave(min2)
    wave(min1)
    wave(maxht2)
    wave(maxht2)
    wave(maxht1)
    wave(max3)
    wave(max3)
    wave(max2)
    wave(max1)
    wave(imp2)
    wave(imp2)
    wave(imp1)
    wave(and4)
    wave(and4)
    wave(and3)
    wave(and3)
    wave(and2)
    wave(and1)
    wave(or4)
    wave(or3)
    wave(or2)
    wave(or2)
    wave(or1)
    wave(or1)
    wave(meminsert2)
    wave(meminsert2)
    wave(meminsert1)
    wave(meminsert1)
    wave(disttwo)
    wave(disttwo)
    red(snd1)
    red(fst1)
    red(pred2)
    red(pred1)
    red(geqzero)
    red(geq3)
    red(geq2)
    red(geq1)
    red(minht2)
    red(minht1)
    red(min3)
    red(min2)
    red(min1)
    red(maxht2)
    red(maxht1)
    red(max3)
    red(max2)
    red(max1)
    red(imp2)
    red(imp1)
    red(and4)
    red(and3)
    red(and2)
    red(and1)
    red(or4)
    red(or3)
    red(or2)
    red(or1)
    trs(default)
    thm(maxhtminht)
    thm(minmaxgeq)
    thm(geqzero)
    thm(meminsert2)
    thm(meminsert1)
    thm(disttwo)
    lemma(ipc_dp_imp_e4)
    lemma(ipc_dp_imp_e3)
    lemma(ipc_dp_imp_e2)
    lemma(cnc_s_bis)
    lemma(succ_nonzero_right)
    lemma(succ_nonzero_left)
    lemma(plesssucc2)
    lemma(plesssucc)
    lemma(list1)
    lemma(arith3)
    lemma(arith2)
    lemma(arith1)
    synth(leq)
    synth(minht)
    synth(maxht)
    scheme(treeind)
    scheme(pairs)
    scheme(list_primitive)
    scheme(pnat_primitive)
    mthd(base_case/1)
    mthd(generalise/2)
    mthd(ind_strat/1)
    mthd(normalize/1)
    smthd(apply_lemma/1)
    smthd(backchain_lemma/1)
    smthd(base_case/1)
    smthd(cancellation/2)
    smthd(casesplit/1)
    smthd(elementary/1)
    smthd(equal/2)
    smthd(existential/2)
    smthd(fertilization_strong/1)
    smthd(fertilize/2)
    smthd(fertilize_left_or_right/1)
    smthd(induction/1)
    smthd(normal/1)
    smthd(normalize_term/1)
    smthd(pw_fertilize/1)
    smthd(pwf/1)
    smthd(pwf_then_fertilize/2)
    smthd(ripple/2)
    smthd(ripple_and_cancel/1)
    smthd(step_case/1)
    smthd(sym_eval/1)
    smthd(unblock/3)
    smthd(unblock_fertilize_lazy/1)
    smthd(unblock_lazy/1)
    smthd(unblock_then_fertilize/2)
    smthd(unblock_then_wave/2)
    smthd(wave/4)
    smthd(weak_fertilize/4)
 */

/* This is the pretty-printed form
ind_strat([(t:int tree)-node(v1,v0)]) then 
  base_case(...)

*/

proof_plan([]==>t:int tree=>geq(maxht(t),minht(t)),maxhtminht,1440,ind_strat(induction(lemma(treeind)-[(t:int tree)-node(v1,v0)])then[base_case(normalize_term([reduction([1],[maxht1,equ(pnat,left)]),reduction([],[geqzero,equiv(left)]),reduction([1,1],[minht1,equ(pnat,left)])])then[elementary(unfold_iff then identity)]),step_case(ripple(direction_out,wave(direction_out,[2],[minht2,equ(pnat,left)],[])then[wave(direction_out,[1],[maxht2,equ(pnat,left)],[])then[wave(direction_out,[],[geq3,equ(u(1),left)],[])then[unblock_then_wave(direction_out,unblock_lazy([unblock(meta_ripple,unused,unused),unblock(meta_ripple,unused,unused),idtac])then wave(direction_out,[],[minmaxgeq,imp(right)],[]))]]])then[unblock_then_fertilize(strong,unblock_fertilize_lazy([idtac])then fertilize(strong,pwf_then_fertilize(strong,fertilization_strong([v2-[1]]))))])])then[base_case(elementary(unfold_iff then intro then[intro(explicit(0))then simplify then wfftacs,hyp(v3)]))],dplan).
